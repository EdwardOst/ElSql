User guide
==========

ElSql is a simple library, deliberately so.
Many other solutions add far more techniques to support interoperation between Java and the SQL database.
This solution simply separates the SQL, as an SQL-like DSL, into an external file.
Basic tools then link back to Java.
Integration with Spring uses the Spring SqlParameterSource class.

The SQL-like DSL contains tags and SQL.
In fact it can contain any text outside the tags, as the SQL itself is not validated.

DSL overview
------------
The DSL is deliberately simple.
It is parsed in a line-by-line basis - no significant element to the parser may wrap over a line.
The DSL is whitespace aware - two spaces are used to create blocks (instead of curly braces).
In combination, this tends to result in readable, if slightly spread out, SQL.

The DSL consists of named snippets.
A snippet may include other snippets allowing a degree of re-use.
An application, wishing to perform a query or update, asks for a named snippet
supplying the set of variables its going to send to JDBC.
The ElSql classes lookup the snippet, resolve the SQL using the specified variables,
and return it to the application that then uses Spring to resolve the variables
themselves into the  final SQL ready for the database call.


Tags
----

The tags cover the common awkward cases when building up SQL queries from Java.
This includes dynamic generation of WHERE clauses, exact or wildcard matching and paging.
Beyond this, there is little if any support - adding more tags complicates the DSL for everyone.

Variables are passed into the DSL using `SqlParameterSource`.
In Spring, this is the object that has to be created anyway, so there is typically no coding overhead here.
Variables are always referred to using a colon prefix within the elsql file.


These are the tags:

@NAME(name)<br />
The name tag creates a named block which can be referred to from the application
or another part of the elsql file. The tag must be on a line by itself.
This is the only permitted tag at the top level.

@INCLUDE(nameOrVariable)<br />
The include tag includes the contents of a named block or a variable (prefixed by colon).
The tag may be embedded in the middle of a line.

@WHERE<br />
The where tag works together with the and/or tags to build dynamic searches.
The tag will output an SQL WHERE, but only if there is at least some content output from the block.
Normally, the where tag is not needed, as there is typically always one active where clause.
The where tag must be on a line by itself.

@AND(expression), @OR(expression)<br />
These tags are equivalent and output SQL AND or OR.
The block that the tag contains is only output if the expression is true.
The output SQL will avoid outputting the AND or OR if it immediately follows a WHERE.
The and/or tag must be on a line by itself.

The expression is evaluated as follows.
If the variable does not exist, then the result is false.
Otherwise, if the expression is (:foo) and foo is a boolean, then the result is the boolean value.
Otherwise, if the expression is (:foo) and foo is not a boolean, then the result is true.
Otherwise, if the expression is (:foo = bar) then the result is true if the variable equals "bar" ignoring case.

@IF(expression)<br />
This tag performs a simple "if statement", as it might in Java.
See above for how the expression is evaluated.

@LIKE sqlWithVariable<br />
@LIKE(variable)<br />
The like tag adds either an SQL = or an SQL LIKE based on the specified variable.
If the tag has no variable in brackets, then the text between the like tag and the end
of the line is parsed for a variable.
This tag can differ by database, so the actual SQL is generated by the configuration class.

@ENDLIKE<br />
The end-like tag is used on rare occasions to scope the end of the like tag.
Normally, the SQL should be written such that the end of the like tag is the end of the line.

@PAGING(offsetVariable,fetchVariable)<br />
The paging tag adds the SQL code to page the results of a search.
These can differ by database, so the actual SQL is generated by the configuration class.
The tag bases its actions on the specified integer variables which should begin with a colon.
This replaces the OFFSETFETCH/FETCH tags in most situations as it enables window functions
to be used where necessary.

@OFFSETFETCH<br />
@OFFSETFETCH(offsetVariable,fetchVariable)<br />
The offset-fetch tag adds the SQL OFFSET and FETCH clauses for paging results.
These can differ by database, so the actual SQL is generated by the configuration class.
The tag bases its actions on the specified integer variables which should begin with a colon.
The names "paging_offset" and "paging_fetch" are used if the variables are not specified.

@FETCH(fetchVariable)<br />
The fetch tag adds the SQL FETCH clause. It works as per the offset-fetch tag.
